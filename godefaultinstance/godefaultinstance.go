// Package godefaultinstance implements the logic for github.com/tcard/godefaultinstance.
package godefaultinstance

import (
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"unicode"
	"unicode/utf8"

	"golang.org/x/tools/go/types"
)

// Config is a configuration for generating a default instance.
type Config struct {
	pkg     string
	typ     string
	ptr     bool
	name    string
	exclude []string
	RawArgs string
}

// NewConfig makes a Config that will generate a variable with the given name
// for the given type. Prefix typ with a * to make a pointer. If name is empty,
// it will be Default<typ>. Methods on typ whose name is in exclude will not be wrapped.
func NewConfig(pkg, typ, name string, exclude []string) (Config, error) {
	ptr := strings.HasPrefix(typ, "*")
	if ptr {
		typ = typ[1:]
	}
	if name == "" {
		name = "Default" + typ
	}
	return NewConfigRaw(pkg, typ, ptr, name, exclude)
}

func NewConfigRaw(pkg string, typ string, ptr bool, name string, exclude []string) (Config, error) {
	if typ == "" {
		return Config{}, errors.New("provided empty type name.")
	}
	if name == "" {
		return Config{}, errors.New("provided empty instance name.")
	}
	r, _ := utf8.DecodeRuneInString(typ)
	if !unicode.Is(unicode.Lu, r) {
		return Config{}, errors.New("cannot generate for unexported type.")
	}
	return Config{pkg, typ, ptr, name, exclude, ""}, nil
}

// Generate a file with name <type>_default_instance.go and put in it the default instance
// and the functions that call methods on it.
func (c Config) Generate(pkgPath string) error {
	a, fset, err := c.GenerateAST(pkgPath)
	if err != nil {
		return err
	}
	f, err := os.Create(filepath.Join(pkgPath, c.typ+"_default_instance.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = fmt.Fprintf(f, "// generated by godefaultinstance %s; DO NOT EDIT\n\n", c.RawArgs)
	if err != nil {
		return err
	}

	return format.Node(f, fset, a)
}

func (c Config) GenerateAST(pkgPath string) (*ast.File, *token.FileSet, error) {
	fset := &token.FileSet{}
	pkgs, err := parser.ParseDir(fset, pkgPath, nil, 0)
	if err != nil {
		return nil, nil, fmt.Errorf("parsing files in %s: %s", pkgPath, err)
	}

	pkg, ok := pkgs[c.pkg]
	if !ok {
		return nil, nil, fmt.Errorf("could not find package %s in %s.", c.pkg, pkgPath)
	}

	var files []*ast.File
	for name, f := range pkg.Files {
		if name == c.typ+"_default_instance.go" {
			continue
		}
		files = append(files, f)
	}

	a, err := c.GenerateFiles(fset, files)
	return a, fset, err
}

func (c Config) GenerateFiles(fset *token.FileSet, files []*ast.File) (*ast.File, error) {
	inf := &types.Info{}
	cfg := &types.Config{
		IgnoreFuncBodies: true,
		Error:            func(err error) {},
	}
	p, err := cfg.Check(c.pkg, fset, files, inf)
	if err != nil {
		return nil, fmt.Errorf("type-checking package: %s", err)
	}
	return c.GeneratePackage(files, p, inf)
}
